#!/usr/bin/env python3
"""
Export XGBoost event predictor model to JavaScript code
This allows the model to run in Cloudflare Workers without ONNX
"""

import pickle
import json
import numpy as np
from pathlib import Path

def export_xgboost_to_js(model_path: str, label_encoder_path: str, output_path: str):
    """Export XGBoost model to JavaScript decision tree code"""

    # Load the model and label encoder
    with open(model_path, 'rb') as f:
        model = pickle.load(f)

    with open(label_encoder_path, 'rb') as f:
        label_encoder = pickle.load(f)

    # Get the booster and dump to JSON
    booster = model.get_booster()

    # Dump trees to JSON format
    trees_json = booster.get_dump(dump_format='json')

    # Parse the JSON trees
    trees = [json.loads(tree) for tree in trees_json]

    print(f"Model info:")
    print(f"  Number of trees: {len(trees)}")
    print(f"  Number of classes: {len(label_encoder.classes_)}")
    print(f"  Classes: {label_encoder.classes_}")

    # Generate JavaScript code
    js_code = generate_js_code(trees, label_encoder.classes_, model)

    # Write to file
    with open(output_path, 'w') as f:
        f.write(js_code)

    print(f"\nExported to: {output_path}")
    print(f"File size: {len(js_code) / 1024:.2f} KB")

def generate_tree_function(tree_data, tree_idx):
    """Generate JavaScript function for a single tree"""

    def generate_node(node, depth=0):
        """Recursively generate JavaScript code for tree nodes"""
        indent = "  " * depth

        if "leaf" in node:
            # Leaf node - return the value
            return f"{indent}return {node['leaf']};\n"

        # Internal node - generate if-else based on split
        split_feature = node.get("split", "")
        split_condition = node.get("split_condition", 0)
        yes_child = node.get("yes", None)
        no_child = node.get("no", None)

        # Find yes and no child nodes
        yes_node = node.get("children", [{}])[0] if "children" in node else {}
        no_node = node.get("children", [{}])[1] if "children" in node and len(node["children"]) > 1 else {}

        code = f"{indent}if (features['{split_feature}'] < {split_condition}) {{\n"
        code += generate_node(yes_node, depth + 1)
        code += f"{indent}}} else {{\n"
        code += generate_node(no_node, depth + 1)
        code += f"{indent}}}\n"

        return code

    func_code = f"function tree{tree_idx}(features) {{\n"
    func_code += generate_node(tree_data, 1)
    func_code += "}\n"

    return func_code

def generate_js_code(trees, class_names, model):
    """Generate complete JavaScript code for the model"""

    num_classes = len(class_names)
    trees_per_class = len(trees) // num_classes

    js_code = """// Auto-generated XGBoost Event Predictor
// DO NOT EDIT - Generated by export_to_js.py

/**
 * Event Predictor Model (XGBoost exported to JavaScript)
 * Predicts event names from activity features
 */

export interface EventFeatures {
  distance_km: number;
  pace_min_per_km: number;
  elevation_gain: number;
  day_of_week: number;
  hour: number;
  month: number;
  contains_parkrun: number;
  contains_marathon: number;
  contains_half: number;
  contains_ultra: number;
  contains_fun_run: number;
  name_length: number;
  is_5k: number;
  is_10k: number;
  is_half_marathon: number;
  is_marathon: number;
  is_ultra: number;
  day_0?: number;
  day_1?: number;
  day_2?: number;
  day_3?: number;
  day_4?: number;
  day_5?: number;
  day_6?: number;
  hour_6?: number;
  hour_7?: number;
  hour_8?: number;
  hour_9?: number;
  hour_10?: number;
}

// Internal type with all features required (used by tree functions)
interface EventFeaturesComplete extends EventFeatures {
  day_0: number;
  day_1: number;
  day_2: number;
  day_3: number;
  day_4: number;
  day_5: number;
  day_6: number;
  hour_6: number;
  hour_7: number;
  hour_8: number;
  hour_9: number;
  hour_10: number;
}

export interface EventPrediction {
  event_name: string;
  probability: number;
  top_3: Array<{
    event_name: string;
    probability: number;
  }>;
  model: string;
}

"""

    # Add class names
    js_code += f"const CLASS_NAMES = {json.dumps(class_names.tolist())};\n\n"

    # Generate tree functions (limit to first 20 trees to keep size down)
    max_trees = min(len(trees), 60)  # Use up to 60 trees for reasonable accuracy
    js_code += f"// Using {max_trees} trees (out of {len(trees)} total)\n\n"

    for i in range(max_trees):
        tree_json = json.loads(model.get_booster().get_dump(dump_format='json')[i])
        js_code += generate_tree_function_v2(tree_json, i)
        js_code += "\n"

    # Generate prediction function
    js_code += f"""
/**
 * Predict event name from activity features
 */
export function predictEvent(inputFeatures: EventFeatures): EventPrediction {{
  // Ensure all one-hot encoded features are present
  const features = {{
    ...inputFeatures,
    day_0: inputFeatures.day_0 ?? 0,
    day_1: inputFeatures.day_1 ?? 0,
    day_2: inputFeatures.day_2 ?? 0,
    day_3: inputFeatures.day_3 ?? 0,
    day_4: inputFeatures.day_4 ?? 0,
    day_5: inputFeatures.day_5 ?? 0,
    day_6: inputFeatures.day_6 ?? 0,
    hour_6: inputFeatures.hour_6 ?? 0,
    hour_7: inputFeatures.hour_7 ?? 0,
    hour_8: inputFeatures.hour_8 ?? 0,
    hour_9: inputFeatures.hour_9 ?? 0,
    hour_10: inputFeatures.hour_10 ?? 0,
  }};

  // Run all trees and sum predictions for each class
  const numClasses = {num_classes};
  const treesPerClass = {trees_per_class};
  const rawScores = new Array(numClasses).fill(0);

  // Get predictions from each tree
  const treeFuncs = [
{', '.join([f'tree{i}' for i in range(max_trees)])}
  ];

  for (let i = 0; i < {max_trees}; i++) {{
    const classIdx = i % numClasses;
    rawScores[classIdx] += treeFuncs[i](features);
  }}

  // Apply softmax to get probabilities
  const maxScore = Math.max(...rawScores);
  const expScores = rawScores.map(score => Math.exp(score - maxScore));
  const sumExp = expScores.reduce((a, b) => a + b, 0);
  const probabilities = expScores.map(exp => exp / sumExp);

  // Get top predictions
  const predictions = CLASS_NAMES.map((name, idx) => ({{
    event_name: name,
    probability: probabilities[idx],
  }})).sort((a, b) => b.probability - a.probability);

  return {{
    event_name: predictions[0].event_name,
    probability: predictions[0].probability,
    top_3: predictions.slice(0, 3),
    model: 'xgboost_js_v1',
  }};
}}
"""

    return js_code

def generate_tree_function_v2(node, tree_idx):
    """Generate a more compact tree function"""

    def clean_feature_name(name):
        """Clean feature name to be valid JavaScript property"""
        # Remove trailing .0 from feature names (e.g., "hour_9.0" -> "hour_9")
        if name.endswith('.0'):
            return name[:-2]
        return name

    def node_to_js(n, var_name="n"):
        """Convert node to JavaScript object notation"""
        if "leaf" in n:
            return str(n["leaf"])

        split = n.get("split", "")
        split_condition = n.get("split_condition", 0)
        children = n.get("children", [])

        if len(children) != 2:
            return "0"

        yes_code = node_to_js(children[0])
        no_code = node_to_js(children[1])

        # Clean the feature name for JavaScript
        clean_split = clean_feature_name(split)

        return f"(features['{clean_split}'] < {split_condition} ? {yes_code} : {no_code})"

    js_expr = node_to_js(node)
    return f"function tree{tree_idx}(features: EventFeaturesComplete): number {{ return {js_expr}; }}"

if __name__ == "__main__":
    model_dir = Path(__file__).parent / "models"
    output_dir = Path(__file__).parent.parent / "workers" / "src" / "utils"

    export_xgboost_to_js(
        model_path=str(model_dir / "event_predictor.pkl"),
        label_encoder_path=str(model_dir / "event_predictor_label_encoder.pkl"),
        output_path=str(output_dir / "event-predictor.ts"),
    )
